/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <stdbool.h>
#include "interface1.h"
#include "interface2.h"
#include "interface3.h"
#include <time.h>
//arreglo para almacenar las canciones
cancion1 vectorCanciones[10];
//contador para las canciones (formato mp3)
int numcancionesMp3 = 0;
//contador para las canciones (formato FLAC)
int numcancionFlac= 0;
//estructura que almacena los datos calculados para envar al servidor de logs
datos_calculados datos_calculadosObj;
//indice para controlar las posiciones del arreglo de canciones
int indice = 0;
struct stat st;
//nombre para crear la carpeta canciones 
const char *name = "canciones";
int tamanio_cancion = 0; 
int tamanio_bloques = 0;
//tamaño acumulado en (MB) de las canciones
int tamanio_mb_canciones = 0;
/**
 * @brief Método para partir una línea 
 * 
 * @param couple 
 * @param tosplit 
 * @param culprit 
 * @return char** cadena partida. 
 */
char** split( char** couple, char* tosplit, char* culprit ) { 
    int i = 0; 
    // Returns first token  
    char *token = strtok( tosplit, culprit);    
    for( int i = 0; token != NULL && i < 2; i++ ) { 
        couple[i] = token; 
        token = strtok(NULL, culprit); 
    } 
    return couple;
}
/**
 * @brief Obtener la extensión de un archivo 
 * 
 * @param filename nombre del archivo 
 * @return const char* retorno. 
 */
const char * get_filename_ext(const char *filename) {
	const char *dot = strrchr(filename, '.');
	if(!dot || dot == filename) return "";
	return dot + 1;
}
/**
 * @brief Método para enviar la canción al servidor
 * 
 * @param nombreArchivo nombre del archivo a enviar
 * @param clnt referencia del cliente que enviará el archivo al servidor. 
 */
void enviarArchivoAlServidor(char * nombreArchivo, CLIENT  *clnt){
	printf("\n Invocando a envar archivo al servidor de respaldo.");
	//fopen abrimos el archivo en modo lectura r 
	FILE *file = fopen(nombreArchivo, "r");
	bool bandera = TRUE; 
	int pos = 0, cantidadBloques = 0; 
	bloque2 objBloque; 
	//se reserva memoria 
	objBloque.nombreArchivo = (char*)malloc(200);
	//se asigna el nombre del archivo
	strcpy(objBloque.nombreArchivo, nombreArchivo);
	//se reserva memoria para los datos que se leen por iteracion
	objBloque.datos.datos_val = (char *)malloc(TAM_MAX_BLOQUE_ARCHIVO * sizeof(char)* 400);
	
	do{
		//la funcion fread lee 1024 bytes del archivo 
		//los guarda en el campo datos_val del campo datos, de la variable objBLoque
		objBloque.datos.datos_len = fread(objBloque.datos.datos_val, 1, TAM_MAX_BLOQUE_ARCHIVO, file);
		//el campo dest_offset almacena la posición desde la cual se realizar la lectura de los 1024 bytes
		objBloque.dest_offset = pos; 
		pos = pos + objBloque.datos.datos_len; 
		//llamado al metodo para enviar el bloque. 
		int *resultado = enviar_bloque_2_2(&objBloque, clnt);
		if(resultado == (int *) NULL){
			clnt_perror(clnt, "call failed");
			bandera = FALSE; 
		}else{
			cantidadBloques ++; 
		}
		//si el ultimo bloque es menor a 1024, es el ultimo bloque del archivo
	} while (objBloque.datos.datos_len == TAM_MAX_BLOQUE_ARCHIVO);
	//libero memoria y cierro el archivo
	free(objBloque.datos.datos_val);
	fclose(file);

	if(bandera == TRUE){
		printf("\n Canción enviar exitosamente a partir de %d bloques", cantidadBloques);
	}else{
		printf("\n Error al enviar la canción");
	}
}
/**
 * @brief Método para enviar la notificacion al servidor de logs. 
 * 
 */
void enviarNotificacion(){
	printf("\n Invocando a enviar notificación");

	//traemos la fecha y hora actual
	time_t t = time(NULL);
	struct tm tiempoLocal = *localtime(&t);

	char fechaHora[50];
	char *formato = "%Y-%m-%d %H:%M:%S";

	int bytesEscritos = strftime(fechaHora, sizeof fechaHora, formato, &tiempoLocal);
	if(bytesEscritos != 0){
		printf("Fecha y Hora: %s", fechaHora);
	}else{
		printf("Error al formateo de fecha");
	}
	//llenamos la estructura 
	datos_calculadosObj.cantidad_canciones_FLAC= numcancionFlac;
	datos_calculadosObj.cantidad_canciones_mp3 = numcancionesMp3;
	strcpy(datos_calculadosObj.fecha_hora, fechaHora);
	datos_calculadosObj.espacio_total_canciones = tamanio_mb_canciones;

	//realizamos el llamado al procedimiento remoto y le pasamos la estructura datos_calculados_obj
	CLIENT *clnt;
	int  *result_3;
	char * crear_archivo_3_3_arg;
	bloque2  enviar_bloque_2_2_arg;
	//reservo memoria 
	crear_archivo_3_3_arg = (char*)malloc(50*sizeof(char));
	crear_archivo_3_3_arg = &datos_calculadosObj;
		
	#ifndef	DEBUG
		clnt = clnt_create ("localhost", programa_compartir_canciones3, programa_compartir_canciones_version_3, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror ("localhost");
			exit (1);
		}
	#endif	/* DEBUG */
		result_3 = enviar_notificacion_3(crear_archivo_3_3_arg, clnt);
		printf("\n result_3 %d", result_3);
		if (result_3 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
			perror("Error al enviar la notificación");
		}else{
			printf("Notificación enviada");
		}

		#ifndef	DEBUG
			clnt_destroy (clnt);
		#endif	 /* DEBUG */
}

/**
 * @brief Recibe los datos de la canción y los guarda en un vector de canciones 
 * 
 * @param argp struct con los datos de la canción 
 * @param rqstp 
 * @return bool_t* resturna true o false si es correcto o incorrecto según corresponda
 */
bool_t * enviar_datos_cancion_1_1_svc(cancion1 *argp, struct svc_req *rqstp) {
	static bool_t  result;

	printf("\nInvocando a registrar canción");
	printf("\nDatos de la canción a registrar");
	printf("\nId de la canción %d", argp->codigoCancion);
	printf("\nTítulo de la canción %s", argp->titulo);
	printf("\n");
	
	//se guarda la canción 
	if(indice != 6){
	vectorCanciones[indice] = *argp;
	result = TRUE;
	}else{
		result = FALSE;
	}
	indice++;
	//verificamos el tipo de la cancion y aumentamos el contador
	if(strcmp(argp->tipo, "mp3") == 0){
		numcancionesMp3++;
	}else if(strcmp(argp->tipo, "FLAC") == 0){
		numcancionFlac++;
	}

	return &result;
}
/**
 * @brief Recibe la canción y la guarda en la carpeta (Canciones)
 * 
 * @param argp nombre del archivo 
 * @param rqstp servicio request. 
 * @return int* Retorna 1 si es correcto y 0 si hay fallo 
 */
int * crear_archivo_1_1_svc(char **argp, struct svc_req *rqstp){
	static int  result;

	printf("\n Invocando a crear canciones");
	printf("\n");

	//se crea la carpeta la primera vez 
	if (stat(name, &st) == -1){
        mkdir(name, S_IRWXU); //lo creo con permisos 
        printf("Directorio canciones creado con éxito\n");
    }
	//reservo memoria y formateo la ruta del archivo a crear. 
	int len = strlen("canciones/");
    char *ruta = malloc(len + strlen(*argp) + 1);
    sprintf(ruta, "canciones/%s", *argp);

	//fopen crea el archivo si no existe y w para escritura
	fopen(ruta, "w");
	return &result;

}
/**
 * @brief Recibe todos los bloques de la cancion y los guarda en canciones/name_cancion.extension
 * 
 * @param argp bloque de cancion 
 * @param rqstp servicio request. 
 * @return int* Retorna 1 si es correcto, 0 si es incorrecto. 
 */
int * enviar_bloque_1_1_svc(bloque1 *argp, struct svc_req *rqstp) {

	static int  result;
	result = 0; 
	FILE *file;
	//Se reserva memoria y se abre el archivo en modo añadir a -> agrega contenido al final  
	int len = strlen("canciones/");
    char *ruta = malloc(len + strlen(argp) + 1);
    sprintf(ruta, "canciones/%s", (*argp).nombreArchivo);

	file = fopen(ruta, "a");
	if(file == NULL){
		result = 1;
	}

	fseek(file, (*argp).dest_offset, SEEK_SET);
	fwrite((*argp).datos.datos_val, 1, (*argp).datos.datos_len, file);
	fclose(file);
	//toca ir acumulando los bytes
	tamanio_cancion = tamanio_cancion + (*argp).datos.datos_len;
	tamanio_bloques++;

	if((*argp).dest_offset == 0){
		printf("\n Primer bloque recibido exitosamente");
		printf("\n");
	}
	else if((*argp).datos.datos_len < TAM_MAX_BLOQUE_ARCHIVO){
		printf("\n Último bloque recibido exitosamente");
		printf("\n Número de bloques recibidos: %d", tamanio_bloques);
		
		//sumar el tamanio a la variable global 
		tamanio_mb_canciones = tamanio_mb_canciones + tamanio_cancion;
		//renombramiento de la cancion 
		int n1 = tamanio_cancion; 
		char *num;
		char buffer[100];
		int len2 = strlen("canciones/");
    	char *ruta2 = malloc(len2 + strlen(argp) + 1);
		char *nombreCancion = malloc(len2 + strlen(argp) + 1); 

		//se convierte un int a char 
		if (asprintf(&num, "_%d", n1) == -1) {
			perror("No se pudo hacer la coherción de tipo");
		} else {
			//ruta inicial de la cancion 
    		sprintf(ruta2, "canciones/%s", (*argp).nombreArchivo);
			//split al nombre de la cancion 
			char delimitador[] = ".";
			char *token = strtok(ruta, delimitador);
			//concatenacion para el nombre nuevo de la cancion 
			strcat(token, num);
			strcat(token, ".mp3");
			rename(ruta2, token);
			free(num);
			//limpio la varible global del tamaño de la cancion 
			tamanio_cancion = 0;
			//formateo el nombre de la cancion para enviar al servidor de respaldo
			char delimitador_formato[] = "/";
			char *nombreFormateado = strtok(token, delimitador_formato);
			if(nombreFormateado != NULL){
				// Sólo en la primera pasamos la cadena; en las siguientes pasamos NULL
				nombreFormateado = strtok(NULL, delimitador_formato);
    		}
			nombreCancion = nombreFormateado;
		}
		//Si el archivo se recibió exitosamente hacemos una copia de seguridad en el servidor 
		//de respaldo 
		CLIENT *clnt;
		int  *result_1;
		char * crear_archivo_2_2_arg;
		int  *result_2;
		bloque2  enviar_bloque_2_2_arg;
		//reservo memoria 
		crear_archivo_2_2_arg = (char*)malloc(40*sizeof(char));
		// crear_archivo_2_2_arg = (*argp).nombreArchivo;
		crear_archivo_2_2_arg = nombreCancion;
		//formatemos el nombre del archivo para enviarlo al servidor de respaldo
		char * nombre_formateado;
		nombre_formateado = malloc(300);
		
		sprintf(nombre_formateado, "canciones/%s", crear_archivo_2_2_arg);
		crear_archivo_2_2_arg = nombre_formateado;
		
		#ifndef	DEBUG
			clnt = clnt_create ("localhost", programa_compartir_canciones2, programa_compartir_canciones_version_2, "tcp");
			if (clnt == NULL) {
				clnt_pcreateerror ("localhost");
				exit (1);
			}
		#endif	/* DEBUG */
			result_1 = crear_archivo_2_2(&crear_archivo_2_2_arg, clnt);
			if (result_1 == (int *) NULL) {
				clnt_perror (clnt, "call failed");
			}else{
				//TODO enviar la cancion al servidor de respaldo 
				printf("\n Archivo vacío creado en el servidor");
				printf("\n Procedimiento a enviar en bloques el archivo");
				printf("%s ", crear_archivo_2_2_arg);
				enviarArchivoAlServidor(crear_archivo_2_2_arg, clnt);

				//TODO enviar notificacion al servidor de logs
				enviarNotificacion();
			}

		#ifndef	DEBUG
			clnt_destroy (clnt);
		#endif	 /* DEBUG */

	}
	return &result;
}
/**
 * @brief metodo del lado del servidor para consultar canciones 
 * 
 * @param argp nombre de la cancion a buscar 
 * @param rqstp Servicio request
 * @return cancion1* structura con los datos de la cacion o NULL. 
 */
cancion1 * consultar_cancion_1_1_svc(char **argp, struct svc_req *rqstp) {
	static cancion1  result;

	printf("\nInvocando a consultar canción");
	printf("\nNombre (título) de la canción a consultar: %s", *argp);	
	printf("\n");

	for (int i = 0; i < 5; i++){
		if (strcmp(vectorCanciones[i].titulo, *argp) == 0){
			printf("\nLa canción %s fue encontrada :-)", vectorCanciones[i].titulo);
			result = vectorCanciones[i];
			return &result;
		}
	}
	return NULL;
}
