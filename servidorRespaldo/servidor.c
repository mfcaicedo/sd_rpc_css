/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "interface2.h"
struct stat st; 
const char *name = "canciones";
int tamanio_cancion = 0; 
int tamanio_bloques = 0;

int * crear_archivo_2_2_svc(char **argp, struct svc_req *rqstp) {
	static int  result;

	printf("\n Invocando a crear canciones servidor respaldo");
	printf("\n");

	//creo la carpeta la primera vez 
	if (stat(name, &st) == -1){
        mkdir(name, S_IRWXU); //lo creo con permisos 
        printf("Directorio canciones creado con exito\n");
    }

	int len = strlen("canciones/");
    char *ruta = malloc(len + strlen(*argp) + 1);
    sprintf(ruta, "canciones/%s", *argp);

	fopen(ruta, "w");
	//fopen crea el archivo si no existe y w para escritura
	return &result;
}

int * enviar_bloque_2_2_svc(bloque2 *argp, struct svc_req *rqstp) {
	static int  result;
	result = 0; 
	FILE *file;
	//abrimos el archivo en modo añadir a -> agrega contenido al final  
	int len = strlen("canciones/");
    char *ruta = malloc(len + strlen(argp) + 1);
    sprintf(ruta, "canciones/%s", (*argp).nombreArchivo);

	file = fopen(ruta, "a");
	if(file == NULL){
		result = 1;
	}

	fseek(file, (*argp).dest_offset, SEEK_SET);
	fwrite((*argp).datos.datos_val, 1, (*argp).datos.datos_len, file);
	fclose(file);
	//toca ir acumulando los bytes
	tamanio_cancion = tamanio_cancion + (*argp).datos.datos_len;
	tamanio_bloques++;

	if((*argp).dest_offset == 0){
		printf("\n Primer bloque recibido exitosamente");
		printf("\n");
	}
	else if((*argp).datos.datos_len < TAM_MAX_BLOQUE_ARCHIVO){
		printf("\n Último bloque recibido exitosamente");
		printf("\n Número de bloques recibidos: %d", tamanio_bloques);
	}

	//renombramiento de la cancion 
	// int n1 = tamanio_cancion;
	// char *num;
	// char buffer[100];
	// //convertimos un int a char 
	// if (asprintf(&num, "_%d", n1) == -1) {
	// 	perror("No se pudo hacer la coherción de tipo");
	// } else {
	// 	//ruta inicial de la cancion 
	// 	int len2 = strlen("canciones/");
	// 	char *ruta2 = malloc(len2 + strlen(argp) + 1);
	// 	sprintf(ruta2, "canciones/%s", (*argp).nombreArchivo);
	// 	//split para el nombre de la cancion 
	// 	char delimitador[] = ".";
	// 	char *token = strtok(ruta, delimitador);
	// 	//concatenacion para el nombre nuevo de la cancion 
	// 	strcat(token, num);
	// 	strcat(token, ".mp3");
	// 	rename(ruta2, token);
	// 	free(num);
	// }

	return &result;
}
