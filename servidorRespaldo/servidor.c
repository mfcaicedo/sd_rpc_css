/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "interface2.h"
struct stat st; 
const char *name = "canciones";
int tamanio_cancion = 0; 
int tamanio_bloques = 0;
/**
 * @brief Metodo del lado del servidor para crear el archivo en la carpeta canciones. 
 * 
 * @param argp nombre del archivo. 
 * @param rqstp servicio request
 * @return int* 1 si es correcto 0 si es incorrecto
 */
int * crear_archivo_2_2_svc(char **argp, struct svc_req *rqstp) {
	static int  result;

	printf("\n Invocando a crear canciones servidor respaldo");
	printf("\n");

	//creo la carpeta la primera vez 
	if (stat(name, &st) == -1){
        mkdir(name, S_IRWXU); //lo creo con permisos 
        printf("Directorio canciones creado con exito\n");
    }
	//reservo memoria y estructuro la ruta del archivo
	int len = strlen("canciones/");
    char *ruta = malloc(len + strlen(*argp) + 1);
    sprintf(ruta, "canciones/%s", *argp);
	//fopen crea el archivo si no existe y w para escritura
	fopen(ruta, "w");
	return &result;
}
/**
 * @brief metodo que guarda el archivo a partir de bloques
 * 
 * @param argp bloque recibido
 * @param rqstp servicio request
 * @return int* 1 correcto | 0 incorrecto
 */
int * enviar_bloque_2_2_svc(bloque2 *argp, struct svc_req *rqstp) {
	static int  result;
	result = 0; 
	FILE *file;
	//abrimos el archivo modo lectura. 
	file = fopen((*argp).nombreArchivo, "a");
	if(file == NULL){
		result = 1;
	}

	fseek(file, (*argp).dest_offset, SEEK_SET);
	fwrite((*argp).datos.datos_val, 1, (*argp).datos.datos_len, file);
	fclose(file);
	//Se acumula los bytes
	tamanio_cancion = tamanio_cancion + (*argp).datos.datos_len;
	tamanio_bloques++;

	if((*argp).dest_offset == 0){
		printf("\n Primer bloque recibido exitosamente");
		printf("\n");
	}
	else if((*argp).datos.datos_len < TAM_MAX_BLOQUE_ARCHIVO){
		printf("\n Último bloque recibido exitosamente");
		printf("\n Número de bloques recibidos: %d", tamanio_bloques);
		printf("\n");

		//renombramiento de la cancion 
		int len_ruta = strlen("canciones/copiaSeguridad_");
		char *nombre_cancion = malloc(len_ruta + strlen(argp) + 1); 
		//formateo el nombre de la cancion
		char delimitador_formato[] = "/";
		char * nombre_cancion_original = malloc(200);
		char *nombre_formateado = strtok((*argp).nombreArchivo, delimitador_formato);
		if(nombre_formateado != NULL){
			// Sólo en la primera pasamos la cadena; en las siguientes pasamos NULL
			nombre_formateado = strtok(NULL, delimitador_formato);
		}
		nombre_cancion = nombre_formateado;

		//formateo el nombre original 
		sprintf(nombre_cancion_original, "canciones/%s",nombre_cancion);
		//formateo el nombre a renombrar la cancion 
		char *ruta_renombrada = malloc(200);
		sprintf(ruta_renombrada, "canciones/copiaSeguridad_%s", nombre_cancion);
		rename(nombre_cancion_original, ruta_renombrada);
	}
	
	return &result;
}
